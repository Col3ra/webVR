<!doctype html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Visor MR de Biomodelos</title>
<style>
  body{margin:0;font-family:system-ui;background:#000;color:#fff}
  #ui{position:fixed;top:10px;left:10px;background:#000a;padding:10px;border-radius:10px;backdrop-filter: blur(4px)}
  #ui input{width:280px}
  #log{position:fixed;bottom:10px;left:10px;right:10px;background:#111a;padding:8px;border-radius:8px;
       max-height:35vh;overflow:auto;font:12px/1.4 ui-monospace,monospace;white-space:pre-wrap}
  canvas{display:block}
</style>

<div id="ui">
  <label>URL del GLB:
    <input id="url" value="modelo1.glb" />
  </label>
  <button id="load">Cargar</button>
  <button id="place">Colocar/Ajustar</button>
  <button id="reset">Reset</button>
  <div>Stick izq: rotar · Stick der: escalar</div>
</div>
<div id="log"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import {GLTFLoader} from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';

const logEl = document.getElementById('log');
const log = (...a)=>{ logEl.textContent += a.join(' ') + '\n' };

let scene=new THREE.Scene(), camera=new THREE.PerspectiveCamera(), 
    renderer=new THREE.WebGLRenderer({alpha:true, antialias:true});
renderer.xr.enabled=true; renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);

let model=null, reticle=null, hitSource=null, xrRefSpace=null, anchor=null;
const loader=new GLTFLoader(); scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.0));

async function loadModel(url){
  try{
    log('Intentando cargar:', url);
    // Prueba rápida de accesibilidad
    const head = await fetch(url, {method:'HEAD'});
    if(!head.ok) throw new Error(`No se puede acceder a ${url} (HTTP ${head.status})`);
    // Limpieza
    if(model){ scene.remove(model); model.traverse(o=>{ o.geometry&&o.geometry.dispose(); o.material&&o.material.dispose(); }); model=null; }
    const glb = await loader.loadAsync(url);
    model = glb.scene; 
    model.traverse(o=>{ if(o.isMesh){ o.castShadow=false; o.receiveShadow=false; }});
    model.visible=false; scene.add(model);
    log('Modelo cargado OK. Bounding box estimado:', new THREE.Box3().setFromObject(model).getSize(new THREE.Vector3()).toArray());
  }catch(e){
    log('ERROR cargando modelo:', e.message);
  }
}

function makeReticle(){
  const geo=new THREE.RingGeometry(0.06,0.07,32).rotateX(-Math.PI/2);
  const mat=new THREE.MeshBasicMaterial({color:0x00ff88});
  reticle=new THREE.Mesh(geo,mat); reticle.matrixAutoUpdate=false; reticle.visible=false; scene.add(reticle);
}

async function startAR(){
  if(!navigator.xr){ log('WebXR no disponible en este navegador. ¿Estás en Quest Browser con HTTPS?'); return; }
  const session = await navigator.xr.requestSession('immersive-ar',{
    requiredFeatures:['hit-test','anchors','local-floor'],
    optionalFeatures:['dom-overlay'], domOverlay:{root:document.body}
  });
  renderer.xr.setReferenceSpaceType('local-floor');
  await renderer.xr.setSession(session);
  xrRefSpace = await session.requestReferenceSpace('local-floor');
  const viewerSpace = await session.requestReferenceSpace('viewer');
  hitSource = await session.requestHitTestSource({space: viewerSpace});
  makeReticle();

  session.addEventListener('select', async (ev)=>{
    if(!reticle?.visible || !model) return;
    const pose = ev.frame.getPose(reticle.anchorSpace ?? reticle.matrix, xrRefSpace);
    if(anchor) anchor.delete();
    anchor = await ev.frame.createAnchor({x:0,y:0,z:0,w:1, position: pose.transform.position}, xrRefSpace);
    model.visible=true;
    log('Anclado en escena');
  });
}

function onXRFrame(t, frame){
  const session = renderer.xr.getSession(); const ref = xrRefSpace; if(!ref) return;
  if(hitSource && frame){
    const hits = frame.getHitTestResults(hitSource);
    if(hits.length){
      const hit = hits[0]; const hitPose = hit.getPose(ref);
      reticle.visible=true; reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
      reticle.updateMatrixWorld(true);
    } else { reticle.visible=false; }
  }
  // Sticks para rotar/escalar
  for(const src of session.inputSources){
    const gp=src.gamepad; if(!gp || !model || !model.visible) continue;
    const [sx,sy]=gp.axes;
    model.rotation.y -= sx*0.02;
    const s=1+sy*0.01; model.scale.multiplyScalar(Math.max(0.01, s));
  }
  renderer.render(scene, camera);
}

document.getElementById('load').onclick=()=>loadModel(document.getElementById('url').value.trim());
document.getElementById('place').onclick=()=>{ reticle && (reticle.visible=true); if(model) model.visible=false; };
document.getElementById('reset').onclick=()=>{ if(anchor){anchor.delete(); anchor=null;} if(model){model.visible=false; model.position.set(0,0,0); model.scale.set(1,1,1);} };

window.addEventListener('resize',()=>renderer.setSize(innerWidth, innerHeight));

// 1) Carga por defecto al abrir
loadModel(document.getElementById('url').value);
// 2) Inicia AR
startAR();
// 3) Log de errores globales
window.addEventListener('error', e=>log('ERROR:', e.message));
window.addEventListener('unhandledrejection', e=>log('PROMISE REJECT:', e.reason?.message || e.reason));
</script>
